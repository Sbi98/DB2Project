package db2project.entity;

import javax.persistence.*;
import java.io.Serializable;
import java.util.*;

@Entity
@Table(name = "product", schema = "DB2Project")
@NamedQueries({
    @NamedQuery(name = "Product.getOfDay", query = "SELECT p FROM Product p WHERE p.date = ?1"),
    @NamedQuery(name = "Product.getAll", query = "SELECT p FROM Product p"),
    @NamedQuery(name = "Product.getBefore", query = "SELECT p FROM Product p Where p.date < ?1")
})
public class Product implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)//Unique id generated by the persistence provider
    private int id;

    private String name;

    @Temporal(TemporalType.DATE)
    private Date date;

    @Basic(fetch = FetchType.LAZY)
    @Lob
    private byte[] image;

    @OneToMany(
        fetch = FetchType.EAGER,//stando al workflow va bene EAGER perché praticamente usiamo sempre le dom di un prod
        mappedBy = "product",
        // quando viene effettuata l'operazione X su di me (Product), effettuala anche a questa relazione (MQuestion)
        cascade = { CascadeType.PERSIST, CascadeType.REFRESH } //l'applicazione non prevede la remove di un prodotto
        //orphanRemoval non necessaria perché l'applicazione non prevede la rimozione di una domanda
    )
    @OrderBy("id asc")
    private List<MQuestion> questions;

    @OneToMany(
        fetch = FetchType.LAZY, //le review di un prodotto sono necessarie solo nella home dell'utente e nell'inspectionPage
        //N.B. eclipseLink usa indirection per le lazy loading: il caricamento lazy può avvenire anche fuori da una tx
        mappedBy = "product",
        // quando viene effettuata l'operazione X su di me (Product), effettuala anche a questa relazione (Review)
        cascade = { CascadeType.REFRESH },
        orphanRemoval = true //se viene tolta una review dalla lista, cancella quella review
    )
    private List<Review> reviews;

    @ManyToMany(fetch = FetchType.LAZY) //necessari solo nelle inspectionPage
    @JoinTable(
        name="deleted_reviews", //nome della jointable
        //nome della colonna che contiene il riferimento a me
        joinColumns={@JoinColumn(name="product_id")},
        //nome della colonna che contiene il riferimento all'altro capo della relazione
        //cioè della colonna che contiene il riferimento all'entità mappata dall'attributo che modella la relazione qui sotto
        inverseJoinColumns={@JoinColumn(name="user_id")}
    )
    private Set<User> repentedUsers;

    public Product() {}

    public Product(String name, Date date, byte[] image) {
        this.name = name;
        this.date = date;
        this.image = image;
    }

    public List<MQuestion> getQuestions() { return questions; }

    public List<Review> getReviews() { return reviews; }

    public Set<User> getRepentedUsers() { return repentedUsers; }

    public void addRepentedUser(User u) { //updates both sides of the relationship
        if (repentedUsers == null) {
            repentedUsers = new HashSet<>();
        }
        repentedUsers.add(u);
        u.addProductWithDeletedReview(this);
    }

    public void removeRepentedUser(User u) { //updates both sides of the relationship
        if (u != null && repentedUsers != null) {
            repentedUsers.remove(u);
            u.removeProductWithDeletedReview(this);
        }
    }

    public void removeReview(Review r) {
        if (r != null && reviews != null) {
            reviews.remove(r);
        }
    }

    protected void addReview(Review r) { //usato dal costruttore di Review per aggiornare l'altro lato della relazione
        if (reviews == null) {
            reviews = new LinkedList<>();
        }
        reviews.add(r);
    }

    protected void addQuestion(MQuestion q) { //usato dal costruttore di MQuestion per aggiornare l'altro lato della relazione
        if (questions == null) {
            questions = new LinkedList<>();
        }
        questions.add(q);
    }

    public String getImageAsBase64() { return Base64.getMimeEncoder().encodeToString(image); }

    public int getId() { return id; }
    //public void setId(int id) { this.id = id; }

    public String getName() { return name; }
    //public void setName(String name) { this.name = name; }

    public byte[] getImage() { return image; }
    //public void setImage(byte[] image) { this.image = image; }

    public Date getDate() { return date; }
    //public void setDate(Date date) { this.date = date; }


}
